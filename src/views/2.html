<p><strong>单例模式</strong></p><p><strong>定义</strong>：单例对象的类只能允许一个实例存在</p><p><strong>实现思路</strong>：</p><ol><li>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例</li><li>在该类内提供一个静态方法，当我们调用这个方法时，如果该类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用</li></ol><p><strong>单例的几种方式</strong>：</p><ol><li>使用模块</li></ol><p>Class Singleton(object):</p><p>	Def foo(self):</p><p>		Pass</p><p>singleton = Singleton()</p><p>from a import singleton</p><ol><li>使用装饰器</li></ol><p>def Singleton(cls):</p><p>		_instance = {}</p><p>		</p><p>		Def _singleton(*args, **kargs):</p><p>			If cls not in _instance:</p><p>				_instance[cls] = cls(*args, **kargs)</p><p>			return _instance[cls]</p><p>return _singleton</p><p>        @Singleton</p><p>		class A(object):</p><p>			a = 1</p><p>			def __init__(self, x=0):</p><p>				self.x = x</p><p>		</p><p>		a1 = A(2)</p><p>		a2 = A(3)</p><ol><li>使用类</li></ol><p>class Singleton(object):</p><p>	</p><p>	def __init__(self):</p><p>		pass</p><p>	@classmethod</p><p>	def instance(cls, *args, **kwargs):</p><p>		if not hasattr(Singleton, “_instance”):</p><p>			Singleton._instance = Singleton(*args, **kwargs)</p><p>		Return Singleton._instance</p><p>import threading</p><p>def task(arg):</p><p>	obj = Singleton.instance()</p><p>	print(obj)</p><p>for i in range(10):</p><p>	t = threading.Thread(target=task,arg=[I,])</p><p>	t.start()</p><% layout('layout') -%>